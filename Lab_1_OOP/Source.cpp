/*
	1.	На один об’єкт відводиться один рядок. Поля відділені крапка з комою (;).
	2.	Кожне завдання реалізувати у вигляді функції.
	3.	Реалізувати перевантаження потоку.
	4.	Результати обробки вхідних даних необхідно зберегти в текстовий файл результатів.

	5.	Кожне завдання оформити у вигляді окремої фукнції.
	6.	Всі оголошення винести в окрему іменовану область.
	7.	Налаштування потоку організувати у вигляді власних маніпуляторів.

	8.	Необхідно зчитати вхідні дані, вивести їх на екран і в файл у форматованому вигляді:
		+	Текстове поле структури повинне бути бути вирівняне
			по лівому полю і займати 15 знакомісць
		+	Числове поле повинне бути вирівняне
			по правому полю і займати 8 знакомісць.
		+	Символ заповнювач «.»
*/

/*
	Описати структуру з іменем COMP, яка містить наступні поля:
		1.	Назва комп’ютера;
		2.	Тактова частота процесора;
		3.	Об’єм ОЗП.

	Написати програму, яка виконує наступні дії:
		+	Зчитування даних з рядкового потоку в масив, який складається зі структур типу COMP
		+	Впорядкувати записи за назвою;
		+	Знайти та вивести на дисплей і у файл список комп’ютерів,
			у яких потужність процесора вища за середню.
		+	Знайти та вивести інформацію про перший знайдений комп’ютер,
			частина імені (не обов’язково з початку) якого збігається з рядком
			введеного з клавіатури.
*/

#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include "Computer.h"

using namespace std;

/*
	Функція підрахунку рядків
*/
size_t countString(istream& in)
{
	size_t count = 0;
	string line;
	while (!in.eof())
	{
		getline(in, line);
		if (in && !line.empty()) ++count;
	}

	return count;
}

int main()
{
	/*
		ВВЕДЕННЯ ІНФОРМАЦІЇ ДО МАСИВУ СТРУКТУР
	*/
	string input_string = "IBM;4500;8\nAPPLE;3400;32\nLENOVO;1845;3";	//	РЯДОК З ІНФОРМАЦІЄЮ

	istringstream input_data(input_string);										//	1.	Відкриття потоку вводу з рядку
	size_t n = countString(input_data);											//	2.	Кількість розділених рядків
	input_data.seekg(0);														//	3.	Відновлення даних у потоці	
	input_data.clear();															//	4.	Скинення прапорців помилок

	NameComp::COMP* array = new NameComp::COMP[n];								//	МАСИВ ЗІ СТРУКТУР COMP
	NameComp::input(array, n, input_data);										//	5.	Введення інформації до масиву

	/*
		ВИВЕДЕННЯ ВХІДНОЇ ІНФОРМАЦІЇ У ФАЙЛ ТА КОНСОЛЬ
	*/
	sort_computers(array, n);													//	Сортування масиву структур за назвою комп'ютерів

	ostringstream result_data;													//	1.	Відкриття потоку виведення
	NameComp::output(array, n, result_data);									//	2.	Виведення інформації з масиву до потоку

	ofstream fout("inputdata.txt");												//	3.	Відкриття файлового потоку виведення
	cout << result_data.str() << endl;											//	4.	Виведення інформації в консоль
	fout << result_data.str() << endl;											//		Виведення інформації у файл
	fout.close();																//	5.	Закриття файлового потоку виведення
	result_data.str("");														//	6.	Очищення потоку виведення

	/*
		ВИВЕДЕННЯ РЕЗУЛЬТАТІВ У ФАЙЛ ТА КОНСОЛЬ
	*/
	ofstream resultout("resultdata.txt");										//	1.	Відкриття файлового потоку виведення

	//	ЗАВДАННЯ 3: Знайти та вивести на дисплей і у файл список комп’ютерів, у яких потужність процесора вища за середню
	freq_above_average(array, n, resultout);									//	Виведення результату в файл
	freq_above_average(array, n, cout);											//	Виведення результату в консоль

	//	ЗАВДАННЯ 4: Знайти та вивести інформацію про перший знайдений комп’ютер, частина імені (не обов’язково з початку) якого збігається з рядком введеного з клавіатури
	cout << "TASK 4. Computer, part of the name of which matches the query" << endl;
	const NameComp::COMP task_second = *find_comp(array, n);
	cout << task_second << endl;												//	Виведення результату в консоль
	resultout << task_second << endl;											//	Виведення результату в файл

	delete[] array;

	system("pause");
	return 0;
}